# -*- coding: utf-8 -*-
"""RP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18YSeZESdd1syvWgxXG-SzuAdoTE_Gh_9
"""

pip install opencv-python

import cv2
import os

# Path to input video
video_path = "/content/restaurnat.mp4"
output_frames_dir = "sample_frames"

# Create output directory to save sample frames
os.makedirs(output_frames_dir, exist_ok=True)

# Open the video file
cap = cv2.VideoCapture(video_path)
frame_count = 0
sample_rate = 30  # Save every 30th frame (~1 per second for 30fps video)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # Save every n-th frame
    if frame_count % sample_rate == 0:
        frame_filename = os.path.join(output_frames_dir, f"frame_{frame_count}.jpg")
        cv2.imwrite(frame_filename, frame)
        print(f"Saved {frame_filename}")

    frame_count += 1

cap.release()
print("‚úÖ Frame extraction complete!")

!pip install ultralytics
!pip install deep_sort_realtime opencv-python

from google.colab.patches import cv2_imshow

"""human detection

"""

from ultralytics import YOLO
from deep_sort_realtime.deepsort_tracker import DeepSort
import cv2

# Load YOLOv8 model (you can use 'yolov8n.pt' for fast inference)
yolo_model = YOLO("yolov8n.pt")  # Use yolov8m.pt or custom model for better accuracy

# DeepSORT tracker
tracker = DeepSort(max_age=30)

# Video input and output
video_path = "/content/restaurnat.mp4"
cap = cv2.VideoCapture(video_path)

width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = int(cap.get(cv2.CAP_PROP_FPS))

out = cv2.VideoWriter("tracked_output.mp4", cv2.VideoWriter_fourcc(*"mp4v"), fps, (width, height))

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # YOLOv8 inference
    results = yolo_model(frame)[0]

    detections = []
    for result in results.boxes.data.tolist():
        x1, y1, x2, y2, score, class_id = result
        class_name = yolo_model.names[int(class_id)]
        if class_name == "person":  # Only track employees
            detections.append(([x1, y1, x2 - x1, y2 - y1], score, class_name))

    # DeepSORT tracking
    tracks = tracker.update_tracks(detections, frame=frame)

    for track in tracks:
        if not track.is_confirmed():
            continue
        track_id = track.track_id
        l, t, w, h = track.to_ltrb()
        cv2.rectangle(frame, (int(l), int(t)), (int(w), int(h)), (0, 255, 0), 2)
        cv2.putText(frame, f"Employee {track_id}", (int(l), int(t) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)

    out.write(frame)
    cv2_imshow(frame)

    if cv2.waitKey(1) & 0xFF == ord("q"):
        break

cap.release()
out.release()
cv2.destroyAllWindows()
print("‚úÖ Detection + Tracking Complete. Video saved as 'tracked_output.mp4'")

import random

# Task List
tasks = [
    "Food Preparation",
    "Cooking",
    "Cleaning and Sanitation",
    "Inventory and Stock Management",
    "Order Management & Coordination",
    "Record-Keeping and Reporting",
    "Training and Team Collaboration"
]

# Simulate for 7 Employees
employee_task_log = {}

for emp_id in range(1, 8):  # Employee IDs from 1 to 7
    num_tasks = random.randint(2, 4)  # Each employee does 2‚Äì4 unique tasks
    chosen_tasks = random.sample(tasks, num_tasks)

    employee_task_log[emp_id] = {
        task: random.randint(4, 12) for task in chosen_tasks
    }

# Show simulated results
for emp_id, log in employee_task_log.items():
    print(f"\nüë®‚Äçüç≥ Employee {emp_id} completed:")
    for task, count in log.items():
        print(f"   - {task}: {count} times")

!pip install ultralytics

"""Task counting and detection"""

import cv2
import random
from ultralytics import YOLO

# Load the YOLOv8 model
model = YOLO("yolov8n.pt")  # or use yolov8s.pt for slightly better accuracy

# Load video
video_path = "/content/restaurnat.mp4"  # Update if needed
cap = cv2.VideoCapture(video_path)

# Output video config
output_path = "/content/restaurant_tracked_simulated.mp4"
fps = cap.get(cv2.CAP_PROP_FPS)
width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

# Task List
tasks = [
    "Food Prep", "Cooking", "Cleaning", "Inventory",
    "Order Mgmt", "Reporting", "Training"
]

# Simulated Employee Tracker (ID: {task info})
employee_registry = {}

def get_random_task_data():
    num_tasks = random.randint(2, 3)
    selected = random.sample(tasks, num_tasks)
    return {task: random.randint(4, 12) for task in selected}

frame_count = 0
max_employees = 7  # Only detect first 7 people

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # Run YOLOv8 detection
    results = model(frame, verbose=False)[0]

    # Filter person detections
    detections = []
    for result in results.boxes.data.tolist():
        x1, y1, x2, y2, score, cls_id = result
        if int(cls_id) == 0 and score > 0.5:
            detections.append((int(x1), int(y1), int(x2), int(y2)))

    # Limit to max_employees
    detections = detections[:max_employees]

    for idx, (x1, y1, x2, y2) in enumerate(detections):
        track_id = idx + 1  # Simulated ID
        if track_id not in employee_registry:
            employee_registry[track_id] = {
                "name": f"Employee {track_id}",
                "tasks": get_random_task_data()
            }

        emp = employee_registry[track_id]
        label = f"{emp['name']}\n"
        for task, count in emp["tasks"].items():
            label += f"{task}: {count}\n"

        # Draw bounding box and task info
        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
        y_offset = y1 - 10
        for line in label.strip().split('\n'):
            cv2.putText(frame, line, (x1, y_offset), cv2.FONT_HERSHEY_SIMPLEX,
                        0.5, (255, 255, 255), 1)
            y_offset -= 15

    out.write(frame)
    frame_count += 1

cap.release()
out.release()
print("‚úÖ Video processing complete!")
print(f"üìÅ Output saved to: {output_path}")



import matplotlib.pyplot as plt

# 1. Summarize total tasks completed per employee
employee_totals = {emp_id: sum(tasks.values()) for emp_id, tasks in employee_data.items()}

# 2. Plot total tasks per employee
plt.figure(figsize=(10, 6))
plt.bar(employee_totals.keys(), employee_totals.values(), color="skyblue")
plt.xlabel('Employee ID')
plt.ylabel('Total Tasks Completed')
plt.title('Total Tasks Completed per Employee')
plt.xticks(range(1, max_employees + 1))
plt.grid(axis='y')
plt.show()

# 3. Prepare data for stacked bar chart
task_names = list(set(task for tasks in employee_data.values() for task in tasks))
task_colors = {task: np.random.rand(3,) for task in task_names}

# Build bars
bottoms = np.zeros(max_employees)
x = np.arange(1, max_employees + 1)

plt.figure(figsize=(5, 5))
for task in task_names:
    heights = [employee_data.get(emp_id, {}).get(task, 0) for emp_id in range(1, max_employees + 1)]
    plt.bar(x, heights, bottom=bottoms, label=task, color=task_colors[task])
    bottoms += heights

plt.xlabel('Employee ID')
plt.ylabel('Tasks Completed')
plt.title('Task Distribution per Employee')
plt.xticks(range(1, max_employees + 1))
plt.legend(title="Task Type", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.grid(axis='y')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# Ensure seaborn theme
sns.set_theme(style="whitegrid")

# Prepare data
employee_ids = list(range(1, 8))  # 1 to 7 employees
employee_totals = {emp_id: sum(tasks.values()) for emp_id, tasks in employee_data.items()}

# Bar plot: Total Tasks Completed per Employee
plt.figure(figsize=(12, 6))
bar_colors = sns.color_palette("Blues_r", 7)

bars = plt.bar(employee_ids, [employee_totals.get(emp_id, 0) for emp_id in employee_ids], color=bar_colors)

# Add numbers on top of bars
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2.0, height + 0.5, int(height), ha='center', va='bottom', fontsize=12, fontweight='bold')

plt.title("Total Tasks Completed by Each Employee", fontsize=18, fontweight='bold')
plt.xlabel("Employee ID", fontsize=14)
plt.ylabel("Number of Tasks Completed", fontsize=14)
plt.xticks(employee_ids, fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

# ==========================

# Stacked bar chart: Task Distribution
task_names = list(set(task for tasks in employee_data.values() for task in tasks))
task_colors = sns.color_palette("husl", len(task_names))

bottoms = np.zeros(7)
x = np.arange(1, 8)

plt.figure(figsize=(14, 8))

for idx, task in enumerate(task_names):
    heights = [employee_data.get(emp_id, {}).get(task, 0) for emp_id in employee_ids]
    plt.bar(x, heights, bottom=bottoms, label=task, color=task_colors[idx])
    bottoms += heights

plt.title("Task Distribution per Employee", fontsize=18, fontweight='bold')
plt.xlabel("Employee ID", fontsize=14)
plt.ylabel("Number of Tasks Completed", fontsize=14)
plt.xticks(employee_ids, fontsize=12)
plt.yticks(fontsize=12)
plt.legend(title="Task Type", bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=12)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Example employee_data dictionary (you already have this from previous steps)
employee_data = {
    1: {'Food Preparation': 6, 'Cooking': 4, 'Cleaning': 2},
    2: {'Inventory': 5, 'Order Management': 7},
    3: {'Cooking': 8, 'Cleaning': 4},
    4: {'Food Preparation': 9, 'Cleaning': 3, 'Inventory': 2},
    5: {'Order Management': 10, 'Cleaning': 2},
    6: {'Record Keeping': 5, 'Training': 7},
    7: {'Cooking': 6, 'Inventory': 6, 'Cleaning': 2}
}

# Set up a nice color palette
pie_colors = sns.color_palette("pastel")

# Create subplots: 2 rows x 4 columns (for 7 employees)
fig, axes = plt.subplots(2, 4, figsize=(24, 12))
axes = axes.flatten()

for idx, emp_id in enumerate(employee_data.keys()):
    ax = axes[idx]
    tasks = employee_data[emp_id]

    labels = list(tasks.keys())
    sizes = list(tasks.values())

    # Plot each employee's pie chart
    wedges, texts, autotexts = ax.pie(
        sizes,
        labels=labels,
        autopct='%1.1f%%',
        startangle=140,
        colors=pie_colors,
        textprops={'fontsize': 12}
    )

    ax.set_title(f"Employee {emp_id} Task Distribution", fontsize=16, fontweight='bold')

# Turn off the extra subplot (8th subplot, not needed)
for j in range(len(employee_data), len(axes)):
    axes[j].axis('off')

# Overall title
plt.suptitle("Employees' Task Completion Percentage Split", fontsize=24, fontweight='bold', color='navy')

# Improve layout
plt.tight_layout(rect=[0, 0, 1, 0.95])

plt.show()